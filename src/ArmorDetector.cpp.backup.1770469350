#include "ArmorDetector.h"
#include <iostream>


// --- 将修改二的代码放在这里，替换旧的阈值定义 ---
// 旧的阈值可能类似于：cv::Scalar red_lower1(0, 100, 100);
// 用以下更严格的阈值替换它们：
cv::Scalar red_lower1 = cv::Scalar(0, 150, 150);
cv::Scalar red_upper1 = cv::Scalar(10, 255, 255);
cv::Scalar red_lower2 = cv::Scalar(160, 150, 150);
cv::Scalar red_upper2 = cv::Scalar(180, 255, 255);

cv::Scalar blue_lower = cv::Scalar(100, 150, 150);
cv::Scalar blue_upper = cv::Scalar(130, 255, 255);
// --- 修改结束 ---



ArmorDetector::ArmorDetector() : target_color(Color::RED) {
    // 创建形态学操作核（3x3矩形）
    kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
}

void ArmorDetector::setColor(Color color) {
    target_color = color;
}

cv::Mat ArmorDetector::preprocess(const cv::Mat& frame) {
    cv::Mat hsv;
    cv::cvtColor(frame, hsv, cv::COLOR_BGR2HSV);

    // 1. 提取红、蓝颜色区域 (捕获光晕)
    cv::Mat red_mask1, red_mask2, red_mask;
    cv::inRange(hsv, red_lower1, red_upper1, red_mask1);
    cv::inRange(hsv, red_lower2, red_upper2, red_mask2);
    red_mask = red_mask1 | red_mask2;

    cv::Mat blue_mask;
    cv::inRange(hsv, blue_lower, blue_upper, blue_mask);
    cv::Mat color_mask = red_mask | blue_mask; // 这是“O”形光晕

    // 2. 【关键增强】提取高亮度区域 (捕获白色核心)
    cv::Mat gray, bright_mask;
    cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);
    // 方法：使用较高的阈值直接提取最亮的部分
    // 参数说明：200是阈值，255是最大值，THRESH_BINARY是二值化类型
    // 这个值可能需要根据你的视频微调：如果核心没出来，就降低（如190）；如果噪声多，就提高（如210）
    cv::threshold(gray, bright_mask, 150, 255, cv::THRESH_BINARY);

    // 3. 融合颜色与亮度信息
    cv::Mat fused_mask;
    cv::bitwise_or(color_mask, bright_mask, fused_mask); // 将光晕与核心合并

    // 4. 【关键连接】形态学操作：弥合“核心”与“光晕”的间隙
    // 第一步：使用一个稍大的核进行闭运算，填充内部空洞，连接邻近区域
    cv::Mat kernel_close = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5));
    cv::morphologyEx(fused_mask, fused_mask, cv::MORPH_CLOSE, kernel_close);

    // 第二步：使用垂直核强化竖条形状的连接性
    cv::Mat kernel_vertical = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(1, 7));
    cv::morphologyEx(fused_mask, fused_mask, cv::MORPH_CLOSE, kernel_vertical);

    // 第三步：轻微膨胀，确保区域饱满连续
    cv::Mat kernel_dilate = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
    cv::dilate(fused_mask, fused_mask, kernel_dilate);

    return fused_mask;
}

void ArmorDetector::getColorMask(const cv::Mat& hsv, cv::Mat& mask) {
    if (target_color == Color::RED) {
        cv::Mat mask1, mask2;
        cv::inRange(hsv, red_lower1, red_upper1, mask1);
        cv::inRange(hsv, red_lower2, red_upper2, mask2);
        mask = mask1 | mask2;
    } else if (target_color == Color::BLUE) {
        cv::inRange(hsv, blue_lower, blue_upper, mask);
    } else {
        mask = cv::Mat::zeros(hsv.size(), CV_8UC1);
    }
}

std::vector<LightBar> ArmorDetector::findLightBars(const cv::Mat& binary) {
    std::vector<LightBar> light_bars;
    
    // 查找轮廓
    std::vector<std::vector<cv::Point>> contours;
    cv::findContours(binary.clone(), contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    // 筛选轮廓
    for (const auto& contour : contours) {
        // 轮廓面积
        double area = cv::contourArea(contour);
        if (area < 50) continue;
        
        // 获取最小外接旋转矩形
        cv::RotatedRect min_rect = cv::minAreaRect(contour);
        
        // 创建LightBar对象
        LightBar light_bar(min_rect);
        
        // 有效性检查
        if (light_bar.isValid()) {
            light_bars.push_back(light_bar);
        }
    }
    
    return light_bars;
}

std::vector<LightBar> ArmorDetector::detect(const cv::Mat& frame) {
    // 预处理（颜色分割）
    cv::Mat binary = preprocess(frame);
    
    // 查找灯条
    std::vector<LightBar> light_bars = findLightBars(binary);
    
    return light_bars;
}